# Definição da classe que representa cada nó da árvore
class No:
    def __init__(self, valor):
        # A valor é o valor armazenado neste nó
        self.valor = valor
        # Inicia o filho à esquerda como null
        self.esquerda = None
        # Inicia o filho à direita como null
        self.direita = None
        # A altura de um novo nó é sempre 1, por ser uma folha
        self.altura = 1


# Definição da Árvore e suas operações
class ArvoreAVL:
    # Função auxiliar para pegar a altura de um nó de forma segura
    def obter_altura(self, no):
        # Se o nó não existir (for None), a altura é 0
        if not no:
            return 0
        # Se não, retorna a altura armazenada no objeto nó
        return no.altura

    # Função para calcular o Fator de Balanceamento
    def balanceamento(self, no):
        # Se o nó não existir, está balanceado
        if not no:
            return 0
        return self.obter_altura(no.esquerda) - self.obter_altura(no.direita) # Fator = Altura da Esquerda - Altura da Direita

    # Função interna para atualizar a altura de um nó após modificações
    def _atualizar_altura(self, no):
        no.altura = 1 + max(self.obter_altura(no.esquerda), self.obter_altura(no.direita)) # A altura é 1 + a maior altura entre seus filhos

    # Rotação simples à direita, usada quando a árvore está pesada para o lado esquerdo
    def rotacao_direita(self, y):
        # y é a raiz que está desbalanceada
        # x será a nova raiz, que é o filho à esquerda de y
        x = y.esquerda
        
        # av2 é a subárvore à direita de x
        av2 = x.direita

        # A direita de x passa a ser o antigo pai y
        x.direita = y
        # A esquerda de y recebe a subárvore av2
        y.esquerda = av2

        # Atualizar o y primeiro, pois ele agora é filho de x
        self._atualizar_altura(y)
        # Depois atualizar x, que é a nova raiz da subárvore
        self._atualizar_altura(x)

        # Retorna x para que o pai anterior aponte para a nova raiz
        return x

    # Rotação Simples à Esquerda, usada quando a árvore está pesada para o lado direito
    def rotacao_esquerda(self, x):
        # x é a raiz atual desbalanceada
        # y será a nova raiz
        y = x.direita
        
        # av2 é a subárvore à esquerda de y
        av2 = y.esquerda

        # A esquerda de y passa a ser o antigo pai x
        y.esquerda = x
        # A direita de x recebe a subárvore av2
        x.direita = av2

        # Atualiza o nó que desceu primeiro
        self._atualizar_altura(x)
        # Atualiza o nó que subiu depois
        self._atualizar_altura(y)

        # Retorna y como nova raiz
        return y

    def inserir(self, raiz, valor):        
        # Se estiver vazio, criamos o nó aqui
        if not raiz:
            return No(valor)
        
        # Se o valor for menor, vai para a esquerda
        elif valor < raiz.valor:
            raiz.esquerda = self.inserir(raiz.esquerda, valor)
        # Se o valor for maior, vai para a direita
        else:
            raiz.direita = self.inserir(raiz.direita, valor)
        
        # Atualiza a altura do nó atual
        self._atualizar_altura(raiz)

        # Verifica se este nó ficou desbalanceado
        balanceamento = self.balanceamento(raiz)

        # Se o nó estiver desbalanceado, há 4 casos possíveis que devemos verificar

        # Esquerda-Esquerda: O nó está pesado para a esquerda, e o novo valor foi inserido na esquerda do filho esquerdo
        if balanceamento > 1 and valor < raiz.esquerda.valor:
            return self.rotacao_direita(raiz)

        # Direita-Direita: O nó está pesado para a direita, e o novo valor foi inserido na direita do filho direito
        if balanceamento < -1 and valor > raiz.direita.valor:
            return self.rotacao_esquerda(raiz)

        # Esquerda-Direita: Pesado para a esquerda, mas o valor foi inserido na direita do filho esquerdo
        if balanceamento > 1 and valor > raiz.esquerda.valor:
            # Rotaciona o filho para a esquerda
            raiz.esquerda = self.rotacao_esquerda(raiz.esquerda)
            # Depois rotaciona o nó atual para a direita
            return self.rotacao_direita(raiz)

        # Direita-Esquerda: Pesado para a direita, mas o valor foi inserido na esquerda do filho direito
        if balanceamento < -1 and valor < raiz.direita.valor:
            # Primeiro rotaciona o filho para a direita
            raiz.direita = self.rotacao_direita(raiz.direita)
            # Depois rotaciona o nó atual para a esquerda
            return self.rotacao_esquerda(raiz)

        # Se não teve rotação, retorna a raiz atual sem alterações
        return raiz
    
    # Função para encontrar o menor valor de uma subárvore, que é usada quando um nó com 2 filhos é removido
    def obter_menor(self, no):
        # Começa pelo nó recebido
        atual = no
        # Vai descendo tudo para a esquerda até achar a ponta
        while atual.esquerda is not None:
            atual = atual.esquerda
        # Retorna o nó mais à esquerda
        return atual

    def remover(self, raiz, valor):        
        # Se a árvore for vazia ou não encontrar o nó
        if not raiz:
            return raiz

        # Navegação até o nó
        if valor < raiz.valor:
            raiz.esquerda = self.remover(raiz.esquerda, valor)
        elif valor > raiz.valor:
            raiz.direita = self.remover(raiz.direita, valor)
        else: # O nó que será removido foi encontrado            
            # Nó com apenas um filho ou nenhum
            if raiz.esquerda is None:
                temp = raiz.direita
                raiz = None # Remove referência
                return temp # Retorna o filho da direita para o pai
            elif raiz.direita is None:
                temp = raiz.esquerda
                raiz = None # Remove referência
                return temp # Retorna o filho da esquerda para o pai

            # Nó com dois filhos: pegar o menor valor da subárvore direita
            temp = self.obter_menor(raiz.direita)
            
            # Copia o valor do sucessor para o nó atual, substituindo o valor a ser deletado
            raiz.valor = temp.valor
            
            # É chamado a remoção recursivamente na direita para apagar o nó sucessor original
            raiz.direita = self.remover(raiz.direita, temp.valor)

        # Se a árvore tinha apenas um nó e ele foi removido, retorna None
        if raiz is None:
            return raiz

        # Atualizar altura do nó atual (recursão voltando)
        self._atualizar_altura(raiz)

        # Verificar fator de balanceamento
        balanceamento = self.balanceamento(raiz)

        # Rebalancear, se necessário
        # Caso Esquerda-Esquerda
        if balanceamento > 1 and self.balanceamento(raiz.esquerda) >= 0:
            return self.rotacao_direita(raiz)

        # Caso Esquerda-Direita
        if balanceamento > 1 and self.balanceamento(raiz.esquerda) < 0:
            raiz.esquerda = self.rotacao_esquerda(raiz.esquerda)
            return self.rotacao_direita(raiz)

        # Caso Direita-Direita
        if balanceamento < -1 and self.balanceamento(raiz.direita) <= 0:
            return self.rotacao_esquerda(raiz)

        # Caso Direita-Esquerda
        if balanceamento < -1 and self.balanceamento(raiz.direita) > 0:
            raiz.direita = self.rotacao_direita(raiz.direita)
            return self.rotacao_esquerda(raiz)

        # Retorna a raiz balanceada
        return raiz

    def buscar(self, raiz, valor):
        # Se a raiz é nula ou o valor é igual
        if raiz is None or raiz.valor == valor:
            return raiz
        # Se a valor é menor, busca na esquerda
        if valor < raiz.valor:
            return self.buscar(raiz.esquerda, valor)
        # Se a valor é maior, busca na direita
        return self.buscar(raiz.direita, valor)

    def imprimir_arvore(self, no, nivel=0, prefixo="Raiz: "):
        if no is None:
            return

        # Imprime o lado direito da árvore
        self.imprimir_arvore(no.direita, nivel + 1, " /-- ")

        # Imprime o nó atual
        espaco = " " * (nivel * 6) # Define a indentação
        print(f"{espaco}{prefixo}{no.valor}")

        # Imprime o lado esquerdo
        self.imprimir_arvore(no.esquerda, nivel + 1, " \\-- ")

# Main
if __name__ == "__main__":
    arvore = ArvoreAVL()
    raiz = None

    lista = [1,2,3,4,5,6]
    print(f"Inserindo: {lista}\n")
    
    for numero in lista:
        raiz = arvore.inserir(raiz, numero)

    print("----- Árvore -----")
    arvore.imprimir_arvore(raiz)
    print("\n" + "="*40 + "\n")
    
    valor_remocao = 2
    print(f"Removendo o nó {valor_remocao}...")
    raiz = arvore.remover(raiz, valor_remocao)
    
    print("Árvore após remoção: ")
    arvore.imprimir_arvore(raiz)
