class No:
    def __init__(self, valor):
        self.valor = valor
        self.esquerda = None
        self.direita = None
        self.altura = 1 # Começa com 1 pois é uma folha.

def pegar_altura(no):
    #Retorna a altura 
    if not no: #Se for None, retorna 0
        return 0
    return no.altura

def balanceamento(no):
    #Calcula se o nó está pesado para esquerda (+) ou direita (-)
    if not no:
        return 0
    return pegar_altura(no.esquerda) - pegar_altura(no.direita)

# --- Funções de Rotação ---

def rotacao_direita(y):
    print(f"  -> Rotação Direita em {y.valor}")
    x = y.esquerda
    a = x.direita

    # Rotação
    x.direita = y
    y.esquerda = a

    # Atualiza alturas (primeiro y, depois x, pois x agora é pai de y)
    y.altura = 1 + max(pegar_altura(y.esquerda), pegar_altura(y.direita))
    x.altura = 1 + max(pegar_altura(x.esquerda), pegar_altura(x.direita))

    return x # Nova raiz

def rotacao_esquerda(x):
    print(f"  -> Rotação Esquerda em {x.valor}")
    y = x.direita
    a = y.esquerda

    # Rotação
    y.esquerda = x
    x.direita = a

    # Atualiza alturas
    x.altura = 1 + max(pegar_altura(x.esquerda), pegar_altura(x.direita))
    y.altura = 1 + max(pegar_altura(y.esquerda), pegar_altura(y.direita))

    return y # Nova raiz

# --- Função de Inserção com Balanceamento AVL ---

def inserir(raiz, valor):
    # Inserção
    if raiz is None:
        return No(valor) #Se não tiver raiz
    
    if valor < raiz.valor: #Se o valor for menor que a raiz
        raiz.esquerda = inserir(raiz.esquerda, valor)
    elif valor > raiz.valor: #Se o valor for maior que a raiz
        raiz.direita = inserir(raiz.direita, valor)
    else:
        return raiz

    #Atualiza a altura do nó ancestral
    raiz.altura = 1 + max(pegar_altura(raiz.esquerda), pegar_altura(raiz.direita))

    #Verifica se ficou desbalanceado
    fator = balanceamento(raiz)

    #Aplica Rotações se necessário (4 Casos)

    # Caso 1: Pesado à Esquerda
    if fator > 1 and valor < raiz.esquerda.valor:
        return rotacao_direita(raiz)

    # Caso 2: Pesado à Direita
    if fator < -1 and valor > raiz.direita.valor:
        return rotacao_esquerda(raiz)

    # Caso 3: Pesado à Esquerda-Direita
    if fator > 1 and valor > raiz.esquerda.valor:
        raiz.esquerda = rotacao_esquerda(raiz.esquerda)
        return rotacao_direita(raiz)

    # Caso 4: Pesado à Direita-Esquerda
    if fator < -1 and valor < raiz.direita.valor:
        raiz.direita = rotacao_direita(raiz.direita)
        return rotacao_esquerda(raiz)

    return raiz

#função de Lista Ordenada
def gerar_lista_ordenada(no):
    lista = [] #Cria uma lista vazia para armazenar os números.
    
    #Define uma função interna para fazer o trabalho pesado da recursão.
    def _percorrer(atual): #Recebe o nó atual
        
        # Se o nó for None (Chegou ao fim de um ramo), para e volta.
        if atual is not None:
            _percorrer(atual.esquerda) #Percorrer esquerda (números menores)
            
            lista.append(atual.valor) #Adiciona o valor do nó atual na lista
            
            _percorrer(atual.direita) #Percorrer direita (números maiores)
            
    # Chama a função interna pela primeira vez, começando pela raiz da árvore.
    _percorrer(no)
    
    return lista

def arvore(no, nivel=0):
    if no is not None: #Se existe No
        if nivel == 0: #Se estiver na raiz
            print(f"Raiz: {no.valor}")
        else:
            prefixo = ' ' * (4 * nivel)
            print(f"{prefixo}-> {no.valor}")
        arvore(no.esquerda, nivel + 1) #Chama recursivamente para esquerda
        arvore(no.direita, nivel + 1) #Chama recursivamente para direita

raiz = None
lista = [5,2,1,9,7,8]
print(f"Inserindo valores: {lista}\n")

for valor in lista:
    print(f"Inserindo {valor}...")
    raiz = inserir(raiz, valor)

print("\n--- Estrutura Final da Árvore (Balanceada) ---")
arvore(raiz)

print("\nLista Ordenada: ", gerar_lista_ordenada(raiz))
